import requests
import time
from datetime import datetime, timedelta
from requests.exceptions import RequestException, ProxyError
import logging
from colorama import init, Fore, Back, Style
import base58
import struct

# 初始化colorama
init(autoreset=True)

# 设置日志
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Alchemy API 网址和API密钥
alchemy_url = "https://solana-mainnet.g.alchemy.com/v2/Flixojc5Cmnk7RFCleAdZXWxDSTar--k"


# 1. 查询代币信息
def get_token_info(token_address):
    headers = {"Content-Type": "application/json"}

    # 直接使用输入的地址作为铸币账户地址
    mint_address = token_address

    # 获取铸币账户的详细信息
    payload = {
        "jsonrpc": "2.0",
        "id": 1,
        "method": "getAccountInfo",
        "params": [
            mint_address,
            {"encoding": "jsonParsed"}
        ]
    }

    response = requests.post(alchemy_url, headers=headers, json=payload)
    if response.status_code != 200:
        raise Exception(f"无法获取铸币账户信息，HTTP状态码: {response.status_code}, 响应: {response.text}")

    result = response.json().get('result', {})
    if not result or not result.get('value'):
        raise Exception(f"未找到铸币账户 {mint_address} 的信息")

    account_data = result['value']['data']
    if account_data['program'] != 'spl-token':
        raise Exception(f"地址 {mint_address} 不是一个有效的SPL代币铸币账户")

    token_info = account_data['parsed']['info']

    return {
        "address": token_address,
        "mint": mint_address,
        "decimals": token_info['decimals'],
        "supply": token_info['supply']
    }


# 2. 获取交易详情
def get_transaction_details(signature, retry=3):
    headers = {"Content-Type": "application/json"}
    payload = {
        "jsonrpc": "2.0",
        "id": 1,
        "method": "getTransaction",
        "params": [
            signature,
            {"encoding": "json", "maxSupportedTransactionVersion": 0}
        ]
    }

    for attempt in range(retry):
        response = requests.post(alchemy_url, headers=headers, json=payload)
        if response.status_code == 200:
            response_json = response.json()
            if 'result' in response_json:
                return response_json['result']
            elif 'error' in response_json:
                raise Exception(f"交易详情错误: {response_json['error']['message']}")
        elif response.status_code == 429:
            wait_time = 2 ** attempt  # 指数退避
            logger.warning(Fore.YELLOW + f"请求过多，等待{wait_time}秒后重试（{attempt + 1}/{retry}）...")
            time.sleep(wait_time)
        else:
            raise Exception(f"无法获取交易详情，HTTP状态码: {response.status_code}, 响应: {response.text}")

    raise Exception(f"在重试{retry}次后仍无法获取交易详情")


# 3. 获取代币交易
def get_token_transactions(token_address, before=None, limit=1000, max_retries=10, initial_delay=0.1):
    headers = {"Content-Type": "application/json"}
    payload = {
        "jsonrpc": "2.0",
        "id": 1,
        "method": "getSignaturesForAddress",
        "params": [
            token_address,
            {"limit": limit}
        ]
    }
    if before:
        payload["params"][1]["before"] = before

    for attempt in range(max_retries):
        try:
            response = requests.post(alchemy_url, headers=headers, json=payload, timeout=30)
            response.raise_for_status()
            response_json = response.json()
            if 'result' in response_json:
                return response_json['result']
            elif 'error' in response_json:
                raise Exception(f"API 错误: {response_json['error']}")
            else:
                raise Exception(f"响应中缺少'result'字段: {response_json}")
        except (RequestException, ProxyError) as e:
            if attempt < max_retries - 1:
                wait_time = initial_delay * (2 ** attempt)  # 指数退避策略
                logger.warning(Fore.YELLOW + f"请求失败，{wait_time:.2f}秒后重试 (尝试 {attempt + 1}/{max_retries})...")
                time.sleep(wait_time)
            else:
                raise Exception(f"在{max_retries}次尝试后仍无法获取交易: {str(e)}")

    raise Exception(f"在{max_retries}次尝试后仍无法获取交易")


# 4. 处理代币交易
def process_token_transaction(tx, token_address, min_sol_amount):
    try:
        details = get_transaction_details(tx['signature'])
        if details and 'meta' in details and 'postTokenBalances' in details['meta']:
            for balance in details['meta']['postTokenBalances']:
                if balance['mint'] == token_address:
                    # 这是涉及我们感兴趣的代币的交易
                    timestamp = datetime.fromtimestamp(details['blockTime']).strftime('%Y-%m-%d %H:%M:%S')
                    sender = details['transaction']['message']['accountKeys'][0]

                    # 计算 SOL 变化
                    pre_balances = details['meta']['preBalances']
                    post_balances = details['meta']['postBalances']
                    sol_change = (pre_balances[0] - post_balances[0]) / 1e9

                    if sol_change >= min_sol_amount:
                        return {
                            "timestamp": timestamp,
                            "signature": tx['signature'],
                            "sender": sender,
                            "sol_amount": sol_change,
                            "wallet_address": sender
                        }
    except Exception as e:
        logger.error(Fore.RED + f"处理交易 {tx['signature']} 时出错: {str(e)}")

    return None


# 5. 检查钱包活跃度
def is_wallet_active(address):
    logger.info(f"正在检查钱包 {address} 的活跃度...")

    headers = {"Content-Type": "application/json"}
    payload = {
        "jsonrpc": "2.0",
        "id": 1,
        "method": "getSignaturesForAddress",
        "params": [
            address,
            {"limit": 10}  # 获取最近10笔交易
        ]
    }

    try:
        response = requests.post(alchemy_url, headers=headers, json=payload)
        if response.status_code == 200:
            response_json = response.json()
            if 'result' in response_json and response_json['result']:
                transactions = response_json['result']

                if len(transactions) < 10:
                    logger.info(Fore.YELLOW + f"钱包 {address} 最近交易少于10笔，被判定为不活跃")
                    return False

                # 获取第10笔交易（最早的一笔）的时间
                oldest_tx_time = datetime.fromtimestamp(transactions[-1]['blockTime'])
                current_time = datetime.now()

                # 判断最早的交易是否在一天之内
                is_active = (current_time - oldest_tx_time) < timedelta(days=1)

                if is_active:
                    logger.info(Fore.GREEN + f"钱包 {address} 最近10笔交易都在一天之内，被判定为活跃")
                else:
                    logger.info(Fore.YELLOW + f"钱包 {address} 最近10笔交易中有超过一天的，被判定为不活跃")

                return is_active
            else:
                logger.info(Fore.YELLOW + f"钱包 {address} 没有交易记录，被判定为不活跃")
                return False
        else:
            raise Exception(f"无法获取交易历史，HTTP状态码: {response.status_code}, 响应: {response.text}")
    except Exception as e:
        logger.error(Fore.RED + f"检查钱包 {address} 活跃度时出错: {str(e)}")
        return False


# 主函数
def main():
    while True:
        token_address = input("请输入代币地址: ")
        min_sol_amount = float(input("请输入最低购买SOL数量: "))
        total_wallet_count = int(input("请输入需要找到的总钱包数量: "))

        try:
            # 获取代币信息
            token_info = get_token_info(token_address)
            logger.info(Fore.CYAN + f"代币地址: {token_info['address']}")
            logger.info(Fore.CYAN + f"代币铸币账户: {token_info['mint']}")
            logger.info(Fore.CYAN + f"代币小数位数: {token_info['decimals']}")
            logger.info(Fore.CYAN + f"代币总供应量: {token_info['supply']}")

            # 直接获取代币相关的所有交易
            all_transactions = []
            before = None
            overall_earliest_time = None

            while True:
                transactions = get_token_transactions(token_address, before)
                if not transactions:
                    break

                all_transactions.extend(transactions)
                batch_earliest_time = datetime.fromtimestamp(transactions[-1]['blockTime'])

                if overall_earliest_time is None or batch_earliest_time < overall_earliest_time:
                    overall_earliest_time = batch_earliest_time

                logger.info(
                    Fore.CYAN + f"已获取 {len(all_transactions)} 笔交易 - 当前批次最早交易时间: {batch_earliest_time.strftime('%Y-%m-%d %H:%M:%S')}")

                before = transactions[-1]['signature']

            logger.info(
                Fore.GREEN + f"获取完成 - 总交易数: {len(all_transactions)}, 最早交易时间: {overall_earliest_time.strftime('%Y-%m-%d %H:%M:%S')}")

            # 按时间顺序排序交易
            sorted_transactions = sorted(all_transactions, key=lambda x: x['blockTime'])
            logger.info(Fore.GREEN + "交易已按时间顺序排序")

            # 处理交易
            active_wallets = []
            inactive_wallets = []
            processed_count = 0
            unique_wallets = set()

            logger.info(Fore.MAGENTA + "开始处理交易...")
            for tx in sorted_transactions:
                processed_count += 1
                tx_time = datetime.fromtimestamp(tx['blockTime']).strftime('%Y-%m-%d %H:%M:%S')
                logger.info(
                    Fore.CYAN + f"正在处理交易 {processed_count}/{len(sorted_transactions)}: {tx['signature']} (时间: {tx_time})")
                result = process_token_transaction(tx, token_info['mint'], min_sol_amount)
                if result:
                    wallet_address = result['wallet_address']
                    if wallet_address not in unique_wallets:
                        unique_wallets.add(wallet_address)
                        if is_wallet_active(wallet_address):
                            active_wallets.append(result)
                            logger.info(Fore.GREEN + f"找到新的活跃钱包: {wallet_address}")
                        else:
                            inactive_wallets.append(result)
                            logger.info(Fore.YELLOW + f"找到新的不活跃钱包: {wallet_address}")

                        if len(unique_wallets) == total_wallet_count:
                            break
                    else:
                        logger.info(Fore.YELLOW + f"跳过重复的钱包地址: {wallet_address}")
                else:
                    logger.info(Fore.YELLOW + f"跳过不满足条件的交易: {tx['signature']}")

            # 打印结果
            logger.info(Fore.MAGENTA + "\n活跃钱包列表:")
            for transaction in active_wallets:
                logger.info(Fore.GREEN + f"时间: {transaction['timestamp']}")
                logger.info(Fore.GREEN + f"签名: {transaction['signature']}")
                logger.info(Fore.GREEN + f"钱包地址: {transaction['wallet_address']}")
                logger.info(Fore.GREEN + f"SOL 变化: {transaction['sol_amount']:.9f} SOL")
                logger.info(Fore.GREEN + "------------------------")

            logger.info(Fore.MAGENTA + "\n不活跃钱包列表:")
            for transaction in inactive_wallets:
                logger.info(Fore.YELLOW + f"时间: {transaction['timestamp']}")
                logger.info(Fore.YELLOW + f"签名: {transaction['signature']}")
                logger.info(Fore.YELLOW + f"钱包地址: {transaction['wallet_address']}")
                logger.info(Fore.YELLOW + f"SOL 变化: {transaction['sol_amount']:.9f} SOL")
                logger.info(Fore.YELLOW + "------------------------")

            logger.info(Fore.CYAN + f"总共处理的交易数: {processed_count}")
            logger.info(Fore.GREEN + f"找到的活跃钱包数: {len(active_wallets)}")
            logger.info(Fore.YELLOW + f"找到的不活跃钱包数: {len(inactive_wallets)}")
            logger.info(Fore.CYAN + f"查询的代币合约地址: {token_address}")

        except KeyboardInterrupt:
            logger.info(Fore.MAGENTA + "\n程序被用户中断")
            break
        except Exception as e:
            logger.error(Fore.RED + f"发生错误: {str(e)}")
            import traceback
            traceback.print_exc()

        # 询问用户是否要继续
        try:
            user_input = input(Fore.MAGENTA + "按Enter键继续新的查询，或输入'q'退出程序: ")
            if user_input.lower() == 'q':
                break
        except KeyboardInterrupt:
            logger.info(Fore.MAGENTA + "\n程序被用户中断")
            break

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        logger.info(Fore.MAGENTA + "\n程序被用户中断")
    finally:
        logger.info(Fore.CYAN + "程序结束")
