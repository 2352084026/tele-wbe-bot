# -*- coding: utf-8 -*-
from decimal import Decimal, getcontext
import datetime
import time
from requests.adapters import HTTPAdapter
from requests.packages.urllib3.util.retry import Retry
from web3 import Web3
from web3.exceptions import BlockNotFound
import pytz
from datetime import datetime, timedelta
import requests
import requests
import concurrent.futures
from functools import partial

# 1inch API 基础 URL
ONEINCH_API_BASE_URL = "https://api.1inch.dev"
# 直接在这里输入你的 API 密钥
ONEINCH_API_KEY = "kcRqgv9yNO9dZKMnPf4VcasBBH1RPB1Z"  # 请将这里替换为你的实际 API 密钥

# 设置 Decimal 的精度
getcontext().prec = 30

# 设置 Alchemy API 密钥
ALCHEMY_API_KEY = 'fcb-bP04qv7tPL6yI7LfJ3Eu0TFd9xWw'

# 设置 Etherscan API 密钥
ETHERSCAN_API_KEY = 'JNV7UHVNJV46UPMD1YC5A9DK2N78J8UQAT'  # 请替换为您的 Etherscan API 密钥

# 连接到以太坊网络
web3 = Web3(Web3.HTTPProvider(f'https://eth-mainnet.g.alchemy.com/v2/{ALCHEMY_API_KEY}'))

if not web3.is_connected():
    print("无法连接到以太坊网络，请检查你的 Alchemy API 密钥")
    exit(1)

print("成功连接到以太坊网络")

# 合约地址和 ABI 定义
UNISWAP_V2_ROUTER = Web3.to_checksum_address('0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D')
WETH = Web3.to_checksum_address('0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2')
USDC = Web3.to_checksum_address('0xA0b86991c6218b36c1d19d4a2e9eb0ce3606eb48')

UNISWAP_V2_ROUTER_ABI = [
    {
        "inputs": [
            {"internalType": "uint256", "name": "amountIn", "type": "uint256"},
            {"internalType": "address[]", "name": "path", "type": "address[]"}
        ],
        "name": "getAmountsOut",
        "outputs": [{"internalType": "uint256[]", "name": "amounts", "type": "uint256[]"}],
        "stateMutability": "view",
        "type": "function"
    }
]

UNISWAP_V2_PAIR_ABI = [
    {
        "anonymous": False,
        "inputs": [
            {"indexed": True, "name": "sender", "type": "address"},
            {"indexed": False, "name": "amount0In", "type": "uint256"},
            {"indexed": False, "name": "amount1In", "type": "uint256"},
            {"indexed": False, "name": "amount0Out", "type": "uint256"},
            {"indexed": False, "name": "amount1Out", "type": "uint256"},
            {"indexed": True, "name": "to", "type": "address"}
        ],
        "name": "Swap",
        "type": "event"
    },
    {
        "constant": True,
        "inputs": [],
        "name": "token0",
        "outputs": [{"name": "", "type": "address"}],
        "type": "function"
    },
    {
        "constant": True,
        "inputs": [],
        "name": "token1",
        "outputs": [{"name": "", "type": "address"}],
        "type": "function"
    },
    {
        "constant": True,
        "inputs": [],
        "name": "getReserves",
        "outputs": [
            {"name": "reserve0", "type": "uint112"},
            {"name": "reserve1", "type": "uint112"},
            {"name": "blockTimestampLast", "type": "uint32"}
        ],
        "type": "function"
    }
]

ERC20_ABI = [
    {
        "constant": True,
        "inputs": [],
        "name": "name",
        "outputs": [{"name": "", "type": "string"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function"
    }
]
WETH_ABI = [
    {
        "constant": True,
        "inputs": [],
        "name": "name",
        "outputs": [{"name": "", "type": "string"}],
        "type": "function"
    },
    {
        "constant": True,
        "inputs": [],
        "name": "symbol",
        "outputs": [{"name": "", "type": "string"}],
        "type": "function"
    },
    {
        "constant": True,
        "inputs": [],
        "name": "decimals",
        "outputs": [{"name": "", "type": "uint8"}],
        "type": "function"
    },
    {
        "anonymous": False,
        "inputs": [
            {"indexed": True, "name": "src", "type": "address"},
            {"indexed": True, "name": "dst", "type": "address"},
            {"indexed": False, "name": "wad", "type": "uint256"}
        ],
        "name": "Transfer",
        "type": "event"
    }
]
# 创建合约实例
uniswap_contract = web3.eth.contract(address=UNISWAP_V2_ROUTER, abi=UNISWAP_V2_ROUTER_ABI)
weth_contract = web3.eth.contract(address=WETH, abi=WETH_ABI)

def get_block_number_by_time(timestamp):
    latest_block = web3.eth.get_block('latest')
    if latest_block['timestamp'] < timestamp:
        print(f"警告：目标时间戳 {timestamp} 超过了最新区块的时间戳 {latest_block['timestamp']}")
        return latest_block['number']

    low = 1
    high = latest_block['number']

    while low <= high:
        mid = (low + high) // 2
        block = web3.eth.get_block(mid)
        if block['timestamp'] < timestamp:
            low = mid + 1
        elif block['timestamp'] > timestamp:
            high = mid - 1
        else:
            return mid

    return high  # 返回最接近但不超过目标时间戳的区块


def get_swap_amount(tx_hash, pair_contract):
    try:
        receipt = web3.eth.get_transaction_receipt(tx_hash)
        for log in receipt['logs']:
            try:
                event = pair_contract.events.Swap().process_log(log)
                if event['address'].lower() == pair_contract.address.lower():
                    # 假设 WETH 是 token0，如果不是，需要交换下面的逻辑
                    if event['args']['amount0In'] > 0:
                        return Web3.from_wei(event['args']['amount0In'], 'ether')
                    elif event['args']['amount0Out'] > 0:
                        return Web3.from_wei(event['args']['amount0Out'], 'ether')
            except:
                continue
    except Exception as e:
        print(f"Error processing transaction {tx_hash}: {e}")
    return Decimal('0')


def get_weth_price_usd():
    try:
        weth_amount_wei = Web3.to_wei(1, 'ether')
        amounts = uniswap_contract.functions.getAmountsOut(
            weth_amount_wei,
            [WETH, USDC]
        ).call()
        weth_price_usd = Decimal(amounts[1]) / Decimal('1e6')  # USDC 是 6 位小数
        return float(weth_price_usd)
    except Exception as e:
        print(f"错误：从Uniswap获取WETH对USD的价格时发生异常: {e}")
        return 0


def is_contract_address(address):
    code = web3.eth.get_code(address)
    return len(code) > 0


def get_address_label(address):
    api_url = f"https://api.etherscan.io/api?module=account&action=txlist&address={address}&apikey={ETHERSCAN_API_KEY}"
    for attempt in range(5):  # Try up to 5 times
        try:
            response = requests_retry_session().get(api_url, timeout=10)
            response.raise_for_status()  # Raises a HTTPError if the status is 4xx, 5xx
            data = response.json()
            if data["status"] == "1" and data["result"]:
                return data["result"][0]["contractAddress"]
            return None
        except requests.exceptions.RequestException as e:
            print(f"Error fetching address label (attempt {attempt+1}): {e}")
            if attempt < 4:  # If it's not the last attempt
                time.sleep(5)  # Wait for 5 seconds before retrying
            else:
                print(f"Failed to get address label for {address} after 5 attempts")
                return None


def get_qualified_addresses(token_contract_address, start_block, end_block, min_buy_weth):
    # Uniswap V2 Factory address
    factory_address = Web3.to_checksum_address('0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f')
    factory_abi = [
        {"inputs": [{"internalType": "address", "name": "_feeToSetter", "type": "address"}], "payable": False,
         "stateMutability": "nonpayable", "type": "constructor"}, {"anonymous": False, "inputs": [
            {"indexed": True, "internalType": "address", "name": "token0", "type": "address"},
            {"indexed": True, "internalType": "address", "name": "token1", "type": "address"},
            {"indexed": False, "internalType": "address", "name": "pair", "type": "address"},
            {"indexed": False, "internalType": "uint256", "name": "", "type": "uint256"}], "name": "PairCreated",
                                                                   "type": "event"},
        {"constant": True, "inputs": [{"internalType": "uint256", "name": "", "type": "uint256"}], "name": "allPairs",
         "outputs": [{"internalType": "address", "name": "", "type": "address"}], "payable": False,
         "stateMutability": "view", "type": "function"}, {"constant": True, "inputs": [], "name": "allPairsLength",
                                                          "outputs": [{"internalType": "uint256", "name": "",
                                                                       "type": "uint256"}], "payable": False,
                                                          "stateMutability": "view", "type": "function"},
        {"constant": False, "inputs": [{"internalType": "address", "name": "tokenA", "type": "address"},
                                       {"internalType": "address", "name": "tokenB", "type": "address"}],
         "name": "createPair", "outputs": [{"internalType": "address", "name": "pair", "type": "address"}],
         "payable": False, "stateMutability": "nonpayable", "type": "function"},
        {"constant": True, "inputs": [], "name": "feeTo",
         "outputs": [{"internalType": "address", "name": "", "type": "address"}], "payable": False,
         "stateMutability": "view", "type": "function"}, {"constant": True, "inputs": [], "name": "feeToSetter",
                                                          "outputs": [{"internalType": "address", "name": "",
                                                                       "type": "address"}], "payable": False,
                                                          "stateMutability": "view", "type": "function"},
        {"constant": True, "inputs": [{"internalType": "address", "name": "", "type": "address"},
                                      {"internalType": "address", "name": "", "type": "address"}], "name": "getPair",
         "outputs": [{"internalType": "address", "name": "", "type": "address"}], "payable": False,
         "stateMutability": "view", "type": "function"},
        {"constant": False, "inputs": [{"internalType": "address", "name": "_feeTo", "type": "address"}],
         "name": "setFeeTo", "outputs": [], "payable": False, "stateMutability": "nonpayable", "type": "function"},
        {"constant": False, "inputs": [{"internalType": "address", "name": "_feeToSetter", "type": "address"}],
         "name": "setFeeToSetter", "outputs": [], "payable": False, "stateMutability": "nonpayable",
         "type": "function"}]

    factory_contract = web3.eth.contract(address=factory_address, abi=factory_abi)

    # Get the pair address
    pair_contract_address = factory_contract.functions.getPair(token_contract_address, WETH).call()

    pair_abi = [{"anonymous": False,
                 "inputs": [{"indexed": True, "internalType": "address", "name": "sender", "type": "address"},
                            {"indexed": False, "internalType": "uint256", "name": "amount0In", "type": "uint256"},
                            {"indexed": False, "internalType": "uint256", "name": "amount1In", "type": "uint256"},
                            {"indexed": False, "internalType": "uint256", "name": "amount0Out", "type": "uint256"},
                            {"indexed": False, "internalType": "uint256", "name": "amount1Out", "type": "uint256"},
                            {"indexed": True, "internalType": "address", "name": "to", "type": "address"}],
                 "name": "Swap", "type": "event"}]

    pair_contract = web3.eth.contract(address=pair_contract_address, abi=pair_abi)

    # Get Swap events
    swap_filter = pair_contract.events.Swap.create_filter(fromBlock=start_block, toBlock=end_block)
    swap_events = swap_filter.get_all_entries()

    qualified_addresses = set()

    for event in swap_events:
        amount0In = event['args']['amount0In']
        amount1In = event['args']['amount1In']
        amount0Out = event['args']['amount0Out']
        amount1Out = event['args']['amount1Out']

        # Determine if this is a buy event (WETH in, token out)
        if amount0In > 0 and amount1Out > 0:  # Assuming WETH is token0
            weth_amount = Web3.from_wei(amount0In, 'ether')
            buyer = event['args']['to']
        elif amount1In > 0 and amount0Out > 0:  # Assuming WETH is token1
            weth_amount = Web3.from_wei(amount1In, 'ether')
            buyer = event['args']['to']
        else:
            continue

        if weth_amount >= min_buy_weth:
            qualified_addresses.add(buyer)
            print(f"找到符合条件的地址: {buyer}, 买入金额: {weth_amount} WETH")
        else:
            print(f"买入金额不足: {weth_amount} WETH < {min_buy_weth} WETH")

    print(f"总共找到 {len(qualified_addresses)} 个符合条件的地址")
    return list(qualified_addresses), pair_contract_address


def get_address_token_transactions(address, token_address, start_time, end_time):
    # 移除start_block和end_block的计算
    url = f"https://api.etherscan.io/api?module=account&action=tokentx&contractaddress={token_address}&address={address}&sort=asc&apikey={ETHERSCAN_API_KEY}"

    transactions = []
    page = 1
    while True:
        response = requests.get(f"{url}&page={page}&offset=1000")
        data = response.json()

        if data['status'] == '1':
            new_transactions = data['result']
            transactions.extend(new_transactions)

            if len(new_transactions) < 1000:
                break

            page += 1
        else:
            print(f"Error fetching transactions: {data['message']}")
            break

    return transactions


def get_token_transfer_amount(tx_hash, address, token_contract):
    try:
        receipt = web3.eth.get_transaction_receipt(tx_hash)
        for log in receipt['logs']:
            try:
                event = token_contract.events.Transfer().process_log(log)
                if event['args']['to'].lower() == address.lower():
                    return Web3.from_wei(event['args']['value'], 'ether')
            except:
                continue
    except Exception as e:
        print(f"Error processing transaction {tx_hash}: {e}")
    return Decimal('0')

def get_eth_value_from_input(tx):
    try:
        # 解析交易输入数据
        input_data = tx['input']
        if isinstance(input_data, str) and input_data.startswith('0x'):
            input_data = bytes.fromhex(input_data[2:])
        if input_data.startswith(b'\x7f\xf3\x6a\xb5'):  # swapExactETHForTokens 函数签名
            # 提取 value 字段，这是实际发送的 ETH 数量
            return Web3.from_wei(tx['value'], 'ether')
    except Exception as e:
        print(f"Error parsing transaction input: {e}")
    return Decimal('0')

def get_internal_transactions(address):
    url = f"https://api.etherscan.io/api?module=account&action=txlistinternal&address={address}&startblock=0&endblock=99999999&sort=asc&apikey={ETHERSCAN_API_KEY}"
    response = requests.get(url)
    if response.status_code == 200:
        data = response.json()
        if data['status'] == '1':
            return data['result']
    return []

def requests_retry_session(
    retries=3,
    backoff_factor=0.3,
    status_forcelist=(500, 502, 504),
    session=None,
):
    session = session or requests.Session()
    retry = Retry(
        total=retries,
        read=retries,
        connect=retries,
        backoff_factor=backoff_factor,
        status_forcelist=status_forcelist,
    )
    adapter = HTTPAdapter(max_retries=retry)
    session.mount('http://', adapter)
    session.mount('https://', adapter)
    return session

def get_internal_transactions_for_tx(tx_hash):
    url = f"https://api.etherscan.io/api?module=account&action=txlistinternal&txhash={tx_hash}&apikey={ETHERSCAN_API_KEY}"
    response = requests.get(url)
    if response.status_code == 200:
        data = response.json()
        if data['status'] == '1':
            return data['result']
    return []

def calculate_profit_addresses_multi_threaded(start_time, end_time, target_profit_usd, token_contract_address, min_buy_weth, max_workers=10):
    start_timestamp = int(datetime.strptime(start_time, "%Y-%m-%d %H:%M:%S").replace(tzinfo=pytz.UTC).timestamp())
    end_timestamp = int(datetime.strptime(end_time, "%Y-%m-%d %H:%M:%S").replace(tzinfo=pytz.UTC).timestamp())

    start_block = get_block_number_by_time(start_timestamp)
    end_block = get_block_number_by_time(end_timestamp)

    print(f"查询区块范围：{start_block} 到 {end_block}")

    qualified_addresses, pair_contract_address = get_qualified_addresses(token_contract_address, start_block, end_block, min_buy_weth)
    print(f"找到 {len(qualified_addresses)} 个满足买入条件的地址")

    # 创建一个偏函数，固定某些参数
    calculate_profit = partial(calculate_address_profit, token_contract_address=token_contract_address, pair_contract_address=pair_contract_address)

    profit_addresses = []
    with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
        future_to_address = {executor.submit(calculate_profit, address): address for address in qualified_addresses}
        for future in concurrent.futures.as_completed(future_to_address):
            address = future_to_address[future]
            try:
                profit_usd = future.result()
                if not is_contract_address(address):
                    label = get_address_label(address)
                    if not (label and 'exchange' in label.lower()):
                        print(f"地址 {address} 的盈利为 ${profit_usd:.2f}")
                        profit_addresses.append((address, profit_usd))
            except Exception as exc:
                print(f'{address} 生成了一个异常: {exc}')

    print("所有地址的盈利情况:")
    for address, profit in profit_addresses:
        print(f"地址: {address}，盈利: ${profit:.2f}")

    return [addr for addr in profit_addresses if addr[1] >= target_profit_usd]


def get_transaction_eth_input(tx_hash):
    tx = web3.eth.get_transaction(tx_hash)
    receipt = web3.eth.get_transaction_receipt(tx_hash)

    total_eth_input = Decimal(Web3.from_wei(tx['value'], 'ether'))

    # 检查内部交易
    internal_txs = get_internal_transactions_for_tx(tx_hash)
    for internal_tx in internal_txs:
        if internal_tx['from'].lower() == tx['from'].lower():
            total_eth_input += Decimal(Web3.from_wei(int(internal_tx['value']), 'ether'))

    return total_eth_input


def calculate_address_profit(address, token_contract_address, pair_contract_address):
    total_usd_spent = Decimal('0')
    total_usd_received = Decimal('0')
    total_tokens_bought = Decimal('0')
    total_tokens_sold = Decimal('0')
    token_balance = Decimal('0')
    eth_balance = Decimal('0')

    token_contract = web3.eth.contract(address=token_contract_address, abi=ERC20_ABI)
    pair_contract = web3.eth.contract(address=pair_contract_address, abi=UNISWAP_V2_PAIR_ABI)

    # 获取该地址的所有代币交易,不限时间范围
    transactions = get_address_token_transactions(address, token_contract_address, None, None)
    transactions.sort(key=lambda x: int(x['timeStamp']))

    processed_tx_hashes = set()

    for tx in transactions:
        tx_hash = tx['hash']
        if tx_hash in processed_tx_hashes:
            continue
        processed_tx_hashes.add(tx_hash)

        print(f"Processing transaction: {tx_hash}")

        # 获取同一交易中的所有代币转移
        related_transfers = [t for t in transactions if t['hash'] == tx_hash]
        total_token_amount_in = sum(Decimal(t['value']) / Decimal(f"1e{t['tokenDecimal']}") for t in related_transfers if t['to'].lower() == address.lower())
        total_token_amount_out = sum(Decimal(t['value']) / Decimal(f"1e{t['tokenDecimal']}") for t in related_transfers if t['from'].lower() == address.lower())

        if total_token_amount_in > 0:  # Receiving tokens
            token_balance += total_token_amount_in

            # 使用函数获取总 ETH 输入
            eth_amount = get_transaction_eth_input(tx_hash)

            if eth_amount > 0:  # Buying tokens
                total_tokens_bought += total_token_amount_in
                usd_spent = eth_amount * Decimal(str(get_weth_price_usd()))
                total_usd_spent += usd_spent
                eth_balance -= eth_amount
                print(f"Bought {total_token_amount_in} tokens for {eth_amount} ETH (${usd_spent})")
            else:
                print(f"Received {total_token_amount_in} tokens (possibly from another source)")

        if total_token_amount_out > 0:  # Sending tokens
            token_balance -= total_token_amount_out
            print(f"Sent {total_token_amount_out} tokens")

            # 卖出逻辑保持不变
            internal_txs = get_internal_transactions_for_tx(tx_hash)
            eth_received = Decimal('0')
            for internal_tx in internal_txs:
                if internal_tx['to'].lower() == address.lower():
                    eth_amount = Decimal(Web3.from_wei(int(internal_tx['value']), 'ether'))
                    eth_received += eth_amount
                    eth_balance += eth_amount

            if eth_received > 0:
                usd_received = eth_received * Decimal(str(get_weth_price_usd()))
                total_usd_received += usd_received
                total_tokens_sold += total_token_amount_out
                print(f"Sold {total_token_amount_out} tokens for {eth_received} ETH (${usd_received})")
            else:
                print(f"No ETH received for this token transfer")

        # 检查余额一致性
        if token_balance < 0:
            print(f"Warning: Negative token balance detected. Resetting to 0.")
            token_balance = Decimal('0')
        if eth_balance < 0:
            print(f"Warning: Negative ETH balance detected. Resetting to 0.")
            eth_balance = Decimal('0')

    remaining_tokens = token_balance

    current_token_price_usd = get_token_price_uniswap(token_contract_address)
    holding_value_usd = remaining_tokens * current_token_price_usd
    total_profit_usd = holding_value_usd + total_usd_received - total_usd_spent

    print(f"地址 {address} 的详细盈利情况:")
    print(f"总花费 USD: ${total_usd_spent:.2f}")
    print(f"总收入 USD: ${total_usd_received:.2f}")
    print(f"总买入代币: {total_tokens_bought:.6f}")
    print(f"总卖出代币: {total_tokens_sold:.6f}")
    print(f"剩余代币: {remaining_tokens:.6f}")
    print(f"当前代币价格 (USD): ${current_token_price_usd:.6f}")
    print(f"当前持仓价值 (USD): ${holding_value_usd:.2f}")
    print(f"总盈利 (USD): ${total_profit_usd:.2f}")
    print(f"交易数量: {len(transactions)}")

    return float(total_profit_usd)
def get_pair_contract_address(token_address):
    UNISWAP_V2_FACTORY = Web3.to_checksum_address('0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f')
    UNISWAP_V2_FACTORY_ABI = [
        {
            "inputs": [
                {"internalType": "address", "name": "tokenA", "type": "address"},
                {"internalType": "address", "name": "tokenB", "type": "address"}
            ],
            "name": "getPair",
            "outputs": [{"internalType": "address", "name": "pair", "type": "address"}],
            "stateMutability": "view",
            "type": "function"
        }
    ]
    factory_contract = web3.eth.contract(address=UNISWAP_V2_FACTORY, abi=UNISWAP_V2_FACTORY_ABI)
    pair_address = factory_contract.functions.getPair(token_address, WETH).call()
    pair_address = Web3.to_checksum_address(pair_address)  # 确保返回的也是校验和地址
    print(f"Pair合约地址: {pair_address}")
    return pair_address

# 修改get_token_price_uniswap函数
# 修改get_token_price_uniswap函数
def get_token_price_uniswap(token_address):
    method = "post"
    apiUrl = "https://api.1inch.dev/price/v1.1/1"
    requestOptions = {
        "headers": {
            "Authorization": "Bearer kcRqgv9yNO9dZKMnPf4VcasBBH1RPB1Z"
        },
        "body": {
            "tokens": [token_address],
            "currency": "USD"
        },
        "params": {}
    }

    headers = requestOptions.get("headers", {})
    body = requestOptions.get("body", {})
    params = requestOptions.get("params", {})

    try:
        response = requests.post(apiUrl, headers=headers, json=body, params=params)
        data = response.json()

        if response.status_code == 200 and token_address.lower() in data:
            token_price_usd = Decimal(data[token_address.lower()])
            print(f"从1inch API获取到的代币价格: ${token_price_usd} USD")
            return token_price_usd
        else:
            print(f"无法从1inch API获取代币 {token_address} 的价格")
            print(f"API响应: {data}")
            return Decimal('0')
    except Exception as e:
        print(f"从1inch API获取代币价格时发生错误: {e}")
        import traceback
        traceback.print_exc()
        return Decimal('0')


def calculate_profit_addresses(start_time, end_time, target_profit_usd, token_contract_address, min_buy_weth):
    start_timestamp = int(datetime.strptime(start_time, "%Y-%m-%d %H:%M:%S").replace(tzinfo=pytz.UTC).timestamp())
    end_timestamp = int(datetime.strptime(end_time, "%Y-%m-%d %H:%M:%S").replace(tzinfo=pytz.UTC).timestamp())

    start_block = get_block_number_by_time(start_timestamp)
    end_block = get_block_number_by_time(end_timestamp)

    print(f"查询区块范围：{start_block} 到 {end_block}")

    qualified_addresses, pair_contract_address = get_qualified_addresses(token_contract_address, start_block, end_block, min_buy_weth)
    print(f"找到 {len(qualified_addresses)} 个满足买入条件的地址")

    profit_addresses = []
    for address in qualified_addresses:
        if is_contract_address(address):
            print(f"跳过合约地址: {address}")
            continue

        label = get_address_label(address)
        if label and 'exchange' in label.lower():
            print(f"跳过可能的交易所地址: {address}")
            continue

        print(f"正在计算地址 {address} 的盈利情况...")
        profit_usd = calculate_address_profit(address, token_contract_address, pair_contract_address, start_time_utc,end_time_utc)
        print(f"地址 {address} 的盈利为 ${profit_usd:.2f}")

        profit_addresses.append((address, profit_usd))

    print("所有地址的盈利情况:")
    for address, profit in profit_addresses:
        print(f"地址: {address}, 盈利: ${profit:.2f}")

    return [addr for addr in profit_addresses if addr[1] >= target_profit_usd]


if __name__ == "__main__":
    try:
        token_contract_address = input("请输入代币合约地址 (Token Contract Address): ")
        token_contract_address = Web3.to_checksum_address(token_contract_address)

        start_time_input = input("请输入开始时间 (格式为 7.25-0.40): ")
        end_time_input = input("请输入结束时间 (格式为 7.25-0.40): ")
        target_profit_usd = float(input("请输入目标盈利金额 (Target Profit in USD): "))
        min_buy_weth = float(input("请输入最小单笔买入WETH数量: "))

        # 预处理时间输入
        current_year = datetime.now().year
        beijing_tz = pytz.timezone('Asia/Shanghai')

        # 处理开始时间
        start_month_day, start_time_part = start_time_input.split('-')
        start_month, start_day = map(int, start_month_day.split('.'))
        start_hour, start_minute = map(int, start_time_part.split('.'))
        start_time_beijing = beijing_tz.localize(datetime(current_year, start_month, start_day, start_hour, start_minute))
        start_time_utc = start_time_beijing.astimezone(pytz.UTC)

        # 处理结束时间
        end_month_day, end_time_part = end_time_input.split('-')
        end_month, end_day = map(int, end_month_day.split('.'))
        end_hour, end_minute = map(int, end_time_part.split('.'))
        end_time_beijing = beijing_tz.localize(datetime(current_year, end_month, end_day, end_hour, end_minute))
        end_time_utc = end_time_beijing.astimezone(pytz.UTC)

        # 格式化时间字符串
        start_time_utc_str = start_time_utc.strftime("%Y-%m-%d %H:%M:%S")
        end_time_utc_str = end_time_utc.strftime("%Y-%m-%d %H:%M:%S")

        print(f"查询的开始时间 (UTC): {start_time_utc_str}")
        print(f"查询的结束时间 (UTC): {end_time_utc_str}")

        # 获取当前最新区块的时间戳
        latest_block = web3.eth.get_block('latest')
        latest_block_timestamp = latest_block['timestamp']
        latest_block_time = datetime.fromtimestamp(latest_block_timestamp, tz=pytz.UTC)

        # 如果查询时间超过了最新区块时间，则使用最新区块时间
        if end_time_utc > latest_block_time:
            end_time_utc = latest_block_time
            print(f"警告：查询结束时间超过了最新区块时间，已调整为最新区块时间")
            print(f"调整后的查询结束时间 (UTC): {end_time_utc}")

        if start_time_utc > latest_block_time:
            start_time_utc = latest_block_time - timedelta(minutes=10)
            print(f"警告：查询开始时间超过了最新区块时间，已调整为最新区块时间前10分钟")
            print(f"调整后的查询开始时间 (UTC): {start_time_utc}")

        start_timestamp = int(start_time_utc.timestamp())
        end_timestamp = int(end_time_utc.timestamp())

        start_block = get_block_number_by_time(start_timestamp)
        end_block = get_block_number_by_time(end_timestamp)

        print(f"查询区块范围：{start_block} 到 {end_block}")
        print(f"查询的代币合约地址: {token_contract_address}")
        print(f"最小单笔买入WETH数量: {min_buy_weth}")

        qualified_addresses, pair_contract_address = get_qualified_addresses(token_contract_address, start_block,
                                                                             end_block, min_buy_weth)
        print(f"符合买入条件的地址数量: {len(qualified_addresses)}")

        profit_addresses = []
        for address in qualified_addresses:
            if is_contract_address(address):
                print(f"跳过合约地址或已知交易所地址: {address}")
                continue

            label = get_address_label(address)
            if label and 'exchange' in label.lower():
                print(f"跳过可能的交易所地址: {address}")
                continue

            print(f"正在计算地址 {address} 的总体盈利情况...")
            profit_usd = calculate_address_profit(address, token_contract_address, pair_contract_address)
            print(f"地址 {address} 的总体盈利为 ${profit_usd:.2f}")
            profit_addresses.append((address, profit_usd))
        print(f"计算完成，找到 {len(profit_addresses)} 个地址")
        print("所有地址的盈利情况:")
        for address, profit in profit_addresses:
            print(f"地址: {address}，盈利: ${profit:.2f}")

        profit_addresses = [addr for addr in profit_addresses if addr[1] >= target_profit_usd]

        if profit_addresses:
            print(f"在指定时间范围内盈利超过 ${target_profit_usd} 的地址数量: {len(profit_addresses)}")
            print("盈利地址列表:")
            for address, profit in profit_addresses:
                print(f"地址: {address}，盈利: ${profit:.2f}")
        else:
            print("没有找到符合条件的盈利地址。")
    except Exception as e:
            print(f"程序执行过程中发生错误: {e}")
            import traceback

            traceback.print_exc()
