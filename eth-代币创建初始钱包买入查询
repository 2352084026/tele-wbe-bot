import requests
from web3 import Web3
import time
from datetime import datetime, timezone, timedelta
import logging
from colorama import init, Fore, Style

# 初始化 colorama
init(autoreset=True)

# 自定义的日志格式化器，用不同颜色输出不同级别的日志
class ColoredFormatter(logging.Formatter):
    COLORS = {
        'DEBUG': Fore.CYAN,
        'INFO': Fore.GREEN,
        'WARNING': Fore.YELLOW,
        'ERROR': Fore.RED,
        'CRITICAL': Fore.RED + Style.BRIGHT,
    }

    def format(self, record):
        log_message = super().format(record)
        return f"{self.COLORS.get(record.levelname, Fore.WHITE)}{log_message}{Style.RESET_ALL}"

# 设置日志
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

# 创建控制台处理器
console_handler = logging.StreamHandler()
console_handler.setLevel(logging.INFO)

# 设置格式化器
formatter = ColoredFormatter('%(asctime)s - %(levelname)s - %(message)s')
console_handler.setFormatter(formatter)

# 将处理器添加到日志记录器
logger.addHandler(console_handler)

# 连接到以太坊网络 (使用 Alchemy)
ALCHEMY_URL = "https://eth-mainnet.g.alchemy.com/v2/fcb-bP04qv7tPL6yI7LfJ3Eu0TFd9xWw"
w3 = Web3(Web3.HTTPProvider(ALCHEMY_URL))

# Etherscan API 密钥
ETHERSCAN_API_KEY = "JNV7UHVNJV46UPMD1YC5A9DK2N78J8UQAT"

# 忽略的合约地址
IGNORED_CONTRACT_ADDRESS = Web3.to_checksum_address("0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97")

# 通用代币 ABI
ERC20_ABI = [
    {
        "constant": True,
        "inputs": [{"name": "_owner", "type": "address"}],
        "name": "balanceOf",
        "outputs": [{"name": "balance", "type": "uint256"}],
        "type": "function"
    },
    {
        "constant": True,
        "inputs": [],
        "name": "decimals",
        "outputs": [{"name": "", "type": "uint8"}],
        "type": "function"
    },
    {
        "anonymous": False,
        "inputs": [
            {"indexed": True, "name": "from", "type": "address"},
            {"indexed": True, "name": "to", "type": "address"},
            {"indexed": False, "name": "value", "type": "uint256"}
        ],
        "name": "Transfer",
        "type": "event"
    }
]

def get_creation_block(contract_address):
    logger.info(f"正在获取合约 {contract_address} 的创建区块...")
    params = {
        "module": "account",
        "action": "txlist",
        "address": contract_address,
        "startblock": 0,
        "endblock": 99999999,
        "sort": "asc",
        "apikey": ETHERSCAN_API_KEY
    }
    response = requests.get("https://api.etherscan.io/api", params=params)
    data = response.json()

    if data["status"] == "1" and len(data["result"]) > 0:
        creation_block = int(data["result"][0]["blockNumber"])
        logger.info(f"合约创建区块: {creation_block}")
        return creation_block
    else:
        logger.error("无法获取创建区块")
        return None

def get_internal_tx(tx_hash):
    logger.debug(f"正在获取交易 {tx_hash} 的内部交易...")
    params = {
        "module": "account",
        "action": "txlistinternal",
        "txhash": tx_hash,
        "apikey": ETHERSCAN_API_KEY
    }
    response = requests.get("https://api.etherscan.io/api", params=params)
    data = response.json()

    if data["status"] == "1":
        logger.debug(f"成功获取内部交易，数量: {len(data['result'])}")
        return data["result"]
    else:
        logger.debug("没有内部交易")
        return []

def analyze_transaction(tx_hash, token_contract, token_decimals, min_amount):
    logger.debug(f"正在分析交易 {tx_hash}...")
    tx = w3.eth.get_transaction(tx_hash)
    receipt = w3.eth.get_transaction_receipt(tx_hash)

    sender = tx['from']

    pre_eth_balance = w3.eth.get_balance(sender, block_identifier=tx.blockNumber - 1)
    post_eth_balance = w3.eth.get_balance(sender, block_identifier=tx.blockNumber)

    eth_change = (pre_eth_balance - post_eth_balance) / 1e18

    pre_token_balance = token_contract.functions.balanceOf(sender).call(block_identifier=tx.blockNumber - 1)
    post_token_balance = token_contract.functions.balanceOf(sender).call(block_identifier=tx.blockNumber)

    token_change = (post_token_balance - pre_token_balance) / (10 ** token_decimals)

    gas_cost = receipt['gasUsed'] * tx['gasPrice'] / 1e18
    eth_change -= gas_cost  # 扣除gas费用

    # 获取内部交易
    internal_txs = get_internal_tx(tx_hash)

    ignored_amount = 0
    # 检查内部交易中是否有转账到忽略的合约地址的情况
    for internal_tx in internal_txs:
        if internal_tx['to'].lower() == IGNORED_CONTRACT_ADDRESS.lower():
            ignored_amount += int(internal_tx['value']) / 1e18

    # 从 eth_change 中减去忽略的金额
    actual_eth_change = eth_change - ignored_amount

    # 修改这里的判断逻辑
    direction = "买入" if actual_eth_change > 0 else "卖出"

    logger.debug(f"交易分析结果: 方向={direction}, ETH变化={actual_eth_change}, 代币变化={token_change}")

    return sender, actual_eth_change, direction, tx_hash, token_change

def is_wallet_active(address, token_contract, current_block):
    logger.info(f"正在检查钱包 {address} 的活跃度...")

    blocks_per_day = 24 * 60 * 60 / 15
    seven_days_blocks = int(7 * blocks_per_day)
    start_block = max(0, current_block - seven_days_blocks)

    # 只检查转入交易（买入）
    incoming_payload = {
        "id": 1,
        "jsonrpc": "2.0",
        "method": "alchemy_getAssetTransfers",
        "params": [
            {
                "fromBlock": hex(start_block),
                "toBlock": "latest",
                "toAddress": address,
                "category": ["erc20"],
                "withMetadata": True,
                "excludeZeroValue": True,
                "maxCount": "0x5",
                "order": "desc"
            }
        ]
    }

    headers = {
        "accept": "application/json",
        "content-type": "application/json"
    }

    try:
        unique_tokens = set()

        # 处理转入交易（买入）
        response = requests.post(ALCHEMY_URL, json=incoming_payload, headers=headers)
        incoming_data = response.json()
        if "result" in incoming_data and "transfers" in incoming_data["result"]:
            for transfer in incoming_data["result"]["transfers"]:
                unique_tokens.add(transfer["asset"])

        if len(unique_tokens) >= 5:
            logger.info(f"钱包 {address} 被判定为活跃（在近期买入了 5 个或更多不同代币）")
            return True
        else:
            logger.info(f"钱包 {address} 被判定为不活跃（在近期买入了少于 5 个不同代币）")
            return False

    except Exception as e:
        logger.error(f"检查钱包 {address} 活跃度时出错: {str(e)}")
        return False

def find_traders(token_address, start_block, min_amount, total_count):
    logger.info(f"开始搜索交易者，目标: 总共 {total_count} 个钱包")
    active_traders = []
    inactive_traders = []
    current_block = w3.eth.block_number

    checksum_token_address = Web3.to_checksum_address(token_address)
    token_contract = w3.eth.contract(address=checksum_token_address, abi=ERC20_ABI)
    token_decimals = token_contract.functions.decimals().call()
    transfer_event = token_contract.events.Transfer()

    block_number = start_block
    processed_txs = set()  # 用于存储已处理的交易哈希

    while (len(active_traders) + len(inactive_traders) < total_count) and block_number <= current_block:
        try:
            logger.info(f"正在处理区块: {block_number}")

            events = transfer_event.get_logs(fromBlock=block_number, toBlock=block_number)

            for event in events:
                tx_hash = event['transactionHash'].hex()
                
                # 检查是否已经处理过这个交易
                if tx_hash in processed_txs:
                    logger.debug(f"跳过已处理的交易: {tx_hash}")
                    continue
                
                processed_txs.add(tx_hash)  # 将交易哈希添加到已处理集合中

                trader, eth_change, direction, tx_hash, token_change = analyze_transaction(tx_hash, token_contract,
                                                                                           token_decimals, min_amount)

                logger.info(f"交易哈希: {tx_hash}")
                logger.info(f"发送者: {trader}")
                logger.info(f"ETH 变化: {eth_change:.6f} ETH")
                logger.info(f"代币变化: {token_change:.6f} 代币")
                logger.info(f"交易方向: {direction}")

                if abs(eth_change) >= min_amount and direction == "买入":
                    tx = w3.eth.get_transaction(tx_hash)
                    block = w3.eth.get_block(tx['blockNumber'])
                    timestamp = block['timestamp']
                    tx_time = datetime.fromtimestamp(timestamp, tz=timezone.utc).strftime('%Y-%m-%d %H:%M:%S UTC')

                    is_active = is_wallet_active(trader, token_contract, current_block)
                    trader_info = (trader, abs(eth_change), tx_hash, tx_time, token_change)

                    if is_active:
                        active_traders.append(trader_info)
                        logger.info(
                            f"找到活跃大额买家: {trader}, 买入数量: {abs(eth_change):.6f} ETH, {token_change:.6f} 代币, 时间: {tx_time}")
                    else:
                        inactive_traders.append(trader_info)
                        logger.info(
                            f"找到不活跃大额买家: {trader}, 买入数量: {abs(eth_change):.6f} ETH, {token_change:.6f} 代币, 时间: {tx_time}")

                    if len(active_traders) + len(inactive_traders) == total_count:
                        logger.info("已找到足够数量的钱包")
                        return active_traders, inactive_traders
                else:
                    logger.info(f"不符合大额交易条件: 金额小于{min_amount} ETH 或非买入交易")

                logger.info("------------------------")  # 添加分隔线以提高可读性

            block_number += 1
        except Exception as e:
            logger.error(f"处理区块 {block_number} 时出错: {e}")
            block_number += 1

    logger.info(f"搜索完成，找到 {len(active_traders)} 个活跃钱包和 {len(inactive_traders)} 个不活跃钱包")
    return active_traders, inactive_traders

def main(token_address, min_amount, total_count):
    logger.info(f"开始分析代币 {token_address}")
    creation_block = get_creation_block(token_address)
    if creation_block is None:
        logger.error("无法获取代币创建区块信息。")
        return

    logger.info(f"代币创建区块: {creation_block}")

    checksum_token_address = Web3.to_checksum_address(token_address)
    active_traders, inactive_traders = find_traders(checksum_token_address, creation_block, min_amount, total_count)

    logger.info("\n活跃大额交易者钱包地址:")
    for trader, amount, tx_hash, tx_time, token_change in active_traders:
        logger.info(
            f"{trader}: 买入 {abs(amount):.6f} ETH, {token_change:.6f} 代币, 交易哈希: {tx_hash}, 时间: {tx_time}")

    logger.info("\n不活跃大额交易者钱包地址:")
    for trader, amount, tx_hash, tx_time, token_change in inactive_traders:
        logger.info(
            f"{trader}: 买入 {abs(amount):.6f} ETH, {token_change:.6f} 代币, 交易哈希: {tx_hash}, 时间: {tx_time}")

if __name__ == "__main__":
    token_address = input("请输入代币合约地址: ")
    min_amount = float(input("请输入最低单笔购买量 (ETH): "))
    total_count = int(input("请输入需要找到的总钱包数量: "))
    main(token_address, min_amount, total_count)
