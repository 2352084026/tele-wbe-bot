import logging
from telegram import Update
from telegram.ext import ApplicationBuilder, CommandHandler, ContextTypes, MessageHandler, filters, ConversationHandler
from decimal import Decimal, getcontext
import datetime
import time
from web3 import Web3
from web3.exceptions import BlockNotFound
import pytz
from datetime import datetime, timedelta
import requests
import concurrent.futures
from functools import partial

# 设置日志
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)

# 设置 Decimal 的精度
getcontext().prec = 30

# API 密钥和配置
ONEINCH_API_BASE_URL = "https://api.1inch.dev"
ONEINCH_API_KEY = "kcRqgv9yNO9dZKMnPf4VcasBBH1RPB1Z"
ALCHEMY_API_KEY = 'fcb-bP04qv7tPL6yI7LfJ3Eu0TFd9xWw'
ETHERSCAN_API_KEY = 'JNV7UHVNJV46UPMD1YC5A9DK2N78J8UQAT'

# 连接到以太坊网络
web3 = Web3(Web3.HTTPProvider(f'https://eth-mainnet.g.alchemy.com/v2/{ALCHEMY_API_KEY}'))

# 合约地址
UNISWAP_V2_ROUTER = Web3.to_checksum_address('0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D')
WETH = Web3.to_checksum_address('0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2')
USDC = Web3.to_checksum_address('0xA0b86991c6218b36c1d19d4a2e9eb0ce3606eb48')

# ABI 定义 (省略了具体内容,使用时请填入完整ABI)
UNISWAP_V2_ROUTER_ABI = [
    {
        "inputs": [
            {"internalType": "uint256", "name": "amountIn", "type": "uint256"},
            {"internalType": "address[]", "name": "path", "type": "address[]"}
        ],
        "name": "getAmountsOut",
        "outputs": [{"internalType": "uint256[]", "name": "amounts", "type": "uint256[]"}],
        "stateMutability": "view",
        "type": "function"
    }
]

UNISWAP_V2_PAIR_ABI = [
    {
        "anonymous": False,
        "inputs": [
            {"indexed": True, "name": "sender", "type": "address"},
            {"indexed": False, "name": "amount0In", "type": "uint256"},
            {"indexed": False, "name": "amount1In", "type": "uint256"},
            {"indexed": False, "name": "amount0Out", "type": "uint256"},
            {"indexed": False, "name": "amount1Out", "type": "uint256"},
            {"indexed": True, "name": "to", "type": "address"}
        ],
        "name": "Swap",
        "type": "event"
    },
    {
        "constant": True,
        "inputs": [],
        "name": "token0",
        "outputs": [{"name": "", "type": "address"}],
        "type": "function"
    },
    {
        "constant": True,
        "inputs": [],
        "name": "token1",
        "outputs": [{"name": "", "type": "address"}],
        "type": "function"
    },
    {
        "constant": True,
        "inputs": [],
        "name": "getReserves",
        "outputs": [
            {"name": "reserve0", "type": "uint112"},
            {"name": "reserve1", "type": "uint112"},
            {"name": "blockTimestampLast", "type": "uint32"}
        ],
        "type": "function"
    }
]

ERC20_ABI = [
    {
        "constant": True,
        "inputs": [],
        "name": "name",
        "outputs": [{"name": "", "type": "string"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function"
    }
]
WETH_ABI = [
    {
        "constant": True,
        "inputs": [],
        "name": "name",
        "outputs": [{"name": "", "type": "string"}],
        "type": "function"
    },
    {
        "constant": True,
        "inputs": [],
        "name": "symbol",
        "outputs": [{"name": "", "type": "string"}],
        "type": "function"
    },
    {
        "constant": True,
        "inputs": [],
        "name": "decimals",
        "outputs": [{"name": "", "type": "uint8"}],
        "type": "function"
    },
    {
        "anonymous": False,
        "inputs": [
            {"indexed": True, "name": "src", "type": "address"},
            {"indexed": True, "name": "dst", "type": "address"},
            {"indexed": False, "name": "wad", "type": "uint256"}
        ],
        "name": "Transfer",
        "type": "event"
    }
]

# 创建合约实例
uniswap_contract = web3.eth.contract(address=UNISWAP_V2_ROUTER, abi=UNISWAP_V2_ROUTER_ABI)
weth_contract = web3.eth.contract(address=WETH, abi=WETH_ABI)

# 定义对话状态
TOKEN_ADDRESS, START_TIME, END_TIME, TARGET_PROFIT, MIN_BUY_WETH, MAX_TX_COUNT = range(6)


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text('欢迎使用ETH地址分析bot! 使用 /analyze 开始分析。')


async def analyze(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text('请输入代币合约地址-如果该地址不是使用eth进行购买会使计算不准确:')
    return TOKEN_ADDRESS


async def token_address(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data['token_address'] = update.message.text
    await update.message.reply_text('请输入开始时间 (格式为 7.25-0.40-此格式代指7月25日零点40分):')
    return START_TIME


async def start_time(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data['start_time'] = update.message.text
    await update.message.reply_text('请输入结束时间 (格式为 7.25-0.40-格式和上面一致)-时间不要太长，不然计算时间会很长，除非你的单笔买入很大:')
    return END_TIME


async def end_time(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data['end_time'] = update.message.text
    await update.message.reply_text('请输入目标总盈利金额-给出20个点左右误差浮动，eth参照价格不一样 -如果输入负数例如-100，则是计算-100及以上亏损地址(USD):')
    return TARGET_PROFIT


async def target_profit(update: Update, context: ContextTypes.DEFAULT_TYPE):
    input_profit = float(update.message.text)
    context.user_data['target_profit'] = input_profit
    if input_profit >= 0:
        await update.message.reply_text('请输入时间段内地址可能的最大单笔买入WETH数量-不能超过实际购买的数量不然找不到，尽量高:')
    else:
        await update.message.reply_text(f'将查找亏损超过 ${abs(input_profit)} 的地址。请输入时间段内地址可能的最大单笔买入WETH数量-不能超过实际购买的数量不然找不到，尽量高:')
    return MIN_BUY_WETH


async def min_buy_weth(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data['min_buy_weth'] = float(update.message.text)
    await update.message.reply_text('请输入最大交易次数-指该地址和该代币交互次数，越少越好，如果你认为它准确的话:')
    return MAX_TX_COUNT


async def max_tx_count(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data['max_tx_count'] = int(update.message.text)
    await update.message.reply_text('正在分析，请稍候...')

    result = run_analysis(context.user_data)

    await update.message.reply_text(result)
    return ConversationHandler.END


def run_analysis(data):
    try:
        token_contract_address = Web3.to_checksum_address(data['token_address'])
        start_time_input = data['start_time']
        end_time_input = data['end_time']
        target_profit_usd = data['target_profit']
        min_buy_weth = data['min_buy_weth']
        max_tx_count = data['max_tx_count']

        is_profit_search = target_profit_usd >= 0

        current_year = datetime.now().year
        beijing_tz = pytz.timezone('Asia/Shanghai')

        start_month_day, start_time_part = start_time_input.split('-')
        start_month, start_day = map(int, start_month_day.split('.'))
        start_hour, start_minute = map(int, start_time_part.split('.'))
        start_time_beijing = beijing_tz.localize(
            datetime(current_year, start_month, start_day, start_hour, start_minute))
        start_time_utc = start_time_beijing.astimezone(pytz.UTC)

        end_month_day, end_time_part = end_time_input.split('-')
        end_month, end_day = map(int, end_month_day.split('.'))
        end_hour, end_minute = map(int, end_time_part.split('.'))
        end_time_beijing = beijing_tz.localize(datetime(current_year, end_month, end_day, end_hour, end_minute))
        end_time_utc = end_time_beijing.astimezone(pytz.UTC)

        start_timestamp = int(start_time_utc.timestamp())
        end_timestamp = int(end_time_utc.timestamp())

        start_block = get_block_number_by_time(start_timestamp)
        end_block = get_block_number_by_time(end_timestamp)

        qualified_addresses, pair_contract_address = get_qualified_addresses(token_contract_address, start_block,
                                                                             end_block, min_buy_weth)

        profit_addresses = []
        for address in qualified_addresses:
            if is_contract_address(address):
                continue

            label = get_address_label(address)
            if label and 'exchange' in label.lower():
                continue

            tx_count = get_address_token_transactions_count(address, token_contract_address)
            if tx_count > max_tx_count:
                continue

            profit_usd = calculate_address_profit(address, token_contract_address, pair_contract_address)
            profit_addresses.append((address, profit_usd))

        if is_profit_search:
            profit_addresses = [addr for addr in profit_addresses if addr[1] >= target_profit_usd]
            result_text = f"在指定时间范围内盈利超过 ${target_profit_usd} 的地址数量: {len(profit_addresses)}\n\n盈利地址列表:\n"
        else:
            loss_threshold = abs(target_profit_usd)
            profit_addresses = [addr for addr in profit_addresses if addr[1] <= -loss_threshold]
            result_text = f"在指定时间范围内亏损超过 ${loss_threshold} 的地址数量: {len(profit_addresses)}\n\n亏损地址列表:\n"

        if profit_addresses:
            for address, profit in profit_addresses:
                result_text += f"地址: {address}, {'盈利' if is_profit_search else '亏损'}: ${abs(profit):.2f}\n"
        else:
            result_text = "没有找到符合条件的地址。"

        return result_text

    except Exception as e:
        return f"分析过程中发生错误: {str(e)}"


# 以下是从原始代码中提取的核心函数
def get_block_number_by_time(timestamp):
    latest_block = web3.eth.get_block('latest')
    if latest_block['timestamp'] < timestamp:
        print(f"警告：目标时间戳 {timestamp} 超过了最新区块的时间戳 {latest_block['timestamp']}")
        return latest_block['number']

    low = 1
    high = latest_block['number']

    while low <= high:
        mid = (low + high) // 2
        block = web3.eth.get_block(mid)
        if block['timestamp'] < timestamp:
            low = mid + 1
        elif block['timestamp'] > timestamp:
            high = mid - 1
        else:
            return mid

    return high  # 返回最接近但不超过目标时间戳的区块


def get_qualified_addresses(token_contract_address, start_block, end_block, min_buy_weth):
    # Uniswap V2 Factory address
    factory_address = Web3.to_checksum_address('0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f')
    factory_abi = [
        {"inputs": [{"internalType": "address", "name": "_feeToSetter", "type": "address"}], "payable": False,
         "stateMutability": "nonpayable", "type": "constructor"}, {"anonymous": False, "inputs": [
            {"indexed": True, "internalType": "address", "name": "token0", "type": "address"},
            {"indexed": True, "internalType": "address", "name": "token1", "type": "address"},
            {"indexed": False, "internalType": "address", "name": "pair", "type": "address"},
            {"indexed": False, "internalType": "uint256", "name": "", "type": "uint256"}], "name": "PairCreated",
                                                                   "type": "event"},
        {"constant": True, "inputs": [{"internalType": "uint256", "name": "", "type": "uint256"}], "name": "allPairs",
         "outputs": [{"internalType": "address", "name": "", "type": "address"}], "payable": False,
         "stateMutability": "view", "type": "function"}, {"constant": True, "inputs": [], "name": "allPairsLength",
                                                          "outputs": [{"internalType": "uint256", "name": "",
                                                                       "type": "uint256"}], "payable": False,
                                                          "stateMutability": "view", "type": "function"},
        {"constant": False, "inputs": [{"internalType": "address", "name": "tokenA", "type": "address"},
                                       {"internalType": "address", "name": "tokenB", "type": "address"}],
         "name": "createPair", "outputs": [{"internalType": "address", "name": "pair", "type": "address"}],
         "payable": False, "stateMutability": "nonpayable", "type": "function"},
        {"constant": True, "inputs": [], "name": "feeTo",
         "outputs": [{"internalType": "address", "name": "", "type": "address"}], "payable": False,
         "stateMutability": "view", "type": "function"}, {"constant": True, "inputs": [], "name": "feeToSetter",
                                                          "outputs": [{"internalType": "address", "name": "",
                                                                       "type": "address"}], "payable": False,
                                                          "stateMutability": "view", "type": "function"},
        {"constant": True, "inputs": [{"internalType": "address", "name": "", "type": "address"},
                                      {"internalType": "address", "name": "", "type": "address"}], "name": "getPair",
         "outputs": [{"internalType": "address", "name": "", "type": "address"}], "payable": False,
         "stateMutability": "view", "type": "function"},
        {"constant": False, "inputs": [{"internalType": "address", "name": "_feeTo", "type": "address"}],
         "name": "setFeeTo", "outputs": [], "payable": False, "stateMutability": "nonpayable", "type": "function"},
        {"constant": False, "inputs": [{"internalType": "address", "name": "_feeToSetter", "type": "address"}],
         "name": "setFeeToSetter", "outputs": [], "payable": False, "stateMutability": "nonpayable",
         "type": "function"}]

    factory_contract = web3.eth.contract(address=factory_address, abi=factory_abi)

    # Get the pair address
    pair_contract_address = factory_contract.functions.getPair(token_contract_address, WETH).call()

    pair_abi = [{"anonymous": False,
                 "inputs": [{"indexed": True, "internalType": "address", "name": "sender", "type": "address"},
                            {"indexed": False, "internalType": "uint256", "name": "amount0In", "type": "uint256"},
                            {"indexed": False, "internalType": "uint256", "name": "amount1In", "type": "uint256"},
                            {"indexed": False, "internalType": "uint256", "name": "amount0Out", "type": "uint256"},
                            {"indexed": False, "internalType": "uint256", "name": "amount1Out", "type": "uint256"},
                            {"indexed": True, "internalType": "address", "name": "to", "type": "address"}],
                 "name": "Swap", "type": "event"}]

    pair_contract = web3.eth.contract(address=pair_contract_address, abi=pair_abi)

    # Get Swap events
    swap_filter = pair_contract.events.Swap.create_filter(fromBlock=start_block, toBlock=end_block)
    swap_events = swap_filter.get_all_entries()

    qualified_addresses = set()

    for event in swap_events:
        amount0In = event['args']['amount0In']
        amount1In = event['args']['amount1In']
        amount0Out = event['args']['amount0Out']
        amount1Out = event['args']['amount1Out']

        # Determine if this is a buy event (WETH in, token out)
        if amount0In > 0 and amount1Out > 0:  # Assuming WETH is token0
            weth_amount = Web3.from_wei(amount0In, 'ether')
            buyer = event['args']['to']
        elif amount1In > 0 and amount0Out > 0:  # Assuming WETH is token1
            weth_amount = Web3.from_wei(amount1In, 'ether')
            buyer = event['args']['to']
        else:
            continue

        if weth_amount >= min_buy_weth:
            qualified_addresses.add(buyer)
            print(f"找到符合条件的地址: {buyer}, 买入金额: {weth_amount} WETH")
        else:
            print(f"地址不符合条件: {buyer}, 买入金额: {weth_amount} WETH")

    print(f"总共找到 {len(qualified_addresses)} 个符合条件的地址")
    return list(qualified_addresses), pair_contract_address


def is_contract_address(address):
    code = web3.eth.get_code(address)
    return len(code) > 0


def get_address_label(address):
    api_url = f"https://api.etherscan.io/api?module=account&action=txlist&address={address}&apikey={ETHERSCAN_API_KEY}"
    response = requests.get(api_url)
    if response.status_code == 200:
        data = response.json()
        if data["status"] == "1" and data["result"]:
            return data["result"][0]["contractAddress"]
    return None


def get_address_token_transactions_count(address, token_address):
    url = f"https://api.etherscan.io/api?module=account&action=tokentx&contractaddress={token_address}&address={address}&sort=asc&apikey={ETHERSCAN_API_KEY}"

    total_tx_count = 0
    page = 1
    while True:
        response = requests.get(f"{url}&page={page}&offset=1000")
        data = response.json()

        if data['status'] == '1':
            new_transactions = data['result']
            total_tx_count += len(new_transactions)

            if len(new_transactions) < 1000:
                break

            page += 1
        else:
            print(f"Error fetching transactions: {data['message']}")
            break

    return total_tx_count


def calculate_address_profit(address, token_contract_address, pair_contract_address, max_retries=10, retry_delay=1):
    for attempt in range(max_retries):
        try:
            total_usd_spent = Decimal('0')
            total_usd_received = Decimal('0')
            total_tokens_bought = Decimal('0')
            total_tokens_sold = Decimal('0')
            token_balance = Decimal('0')
            eth_balance = Decimal('0')

            token_contract = web3.eth.contract(address=token_contract_address, abi=ERC20_ABI)
            pair_contract = web3.eth.contract(address=pair_contract_address, abi=UNISWAP_V2_PAIR_ABI)

            # 获取该地址的所有代币交易,不限时间范围
            transactions = get_address_token_transactions(address, token_contract_address, None, None)
            transactions.sort(key=lambda x: int(x['timeStamp']))

            processed_tx_hashes = set()

            for tx in transactions:
                tx_hash = tx['hash']
                if tx_hash in processed_tx_hashes:
                    continue
                processed_tx_hashes.add(tx_hash)

                print(f"Processing transaction: {tx_hash}")

                # 获取同一交易中的所有代币转移
                related_transfers = [t for t in transactions if t['hash'] == tx_hash]
                total_token_amount_in = sum(
                    Decimal(t['value']) / Decimal(f"1e{t['tokenDecimal']}") for t in related_transfers if
                    t['to'].lower() == address.lower())
                total_token_amount_out = sum(
                    Decimal(t['value']) / Decimal(f"1e{t['tokenDecimal']}") for t in related_transfers if
                    t['from'].lower() == address.lower())

                if total_token_amount_in > 0:  # Receiving tokens
                    token_balance += total_token_amount_in

                    # 使用函数获取总 ETH 输入
                    eth_amount = get_transaction_eth_input(tx_hash)

                    if eth_amount > 0:  # Buying tokens
                        total_tokens_bought += total_token_amount_in
                        usd_spent = eth_amount * Decimal(str(get_weth_price_usd()))
                        total_usd_spent += usd_spent
                        eth_balance -= eth_amount
                        print(f"Bought {total_token_amount_in} tokens for {eth_amount} ETH (${usd_spent})")
                    else:
                        print(f"Received {total_token_amount_in} tokens (possibly from another source)")

                if total_token_amount_out > 0:  # Sending tokens
                    token_balance -= total_token_amount_out
                    print(f"Sent {total_token_amount_out} tokens")

                    # 卖出逻辑保持不变
                    internal_txs = get_internal_transactions_for_tx(tx_hash)
                    eth_received = Decimal('0')
                    for internal_tx in internal_txs:
                        if internal_tx['to'].lower() == address.lower():
                            eth_amount = Decimal(Web3.from_wei(int(internal_tx['value']), 'ether'))
                            eth_received += eth_amount
                            eth_balance += eth_amount

                    if eth_received > 0:
                        usd_received = eth_received * Decimal(str(get_weth_price_usd()))
                        total_usd_received += usd_received
                        total_tokens_sold += total_token_amount_out
                        print(f"Sold {total_token_amount_out} tokens for {eth_received} ETH (${usd_received})")
                    else:
                        print(f"No ETH received for this token transfer")

                # 检查余额一致性
                if token_balance < 0:
                    print(f"Warning: Negative token balance detected. Resetting to 0.")
                    token_balance = Decimal('0')
                if eth_balance < 0:
                    print(f"Warning: Negative ETH balance detected. Resetting to 0.")
                    eth_balance = Decimal('0')

            remaining_tokens = token_balance

            current_token_price_usd = get_token_price_uniswap(token_contract_address)
            holding_value_usd = remaining_tokens * current_token_price_usd
            total_profit_usd = holding_value_usd + total_usd_received - total_usd_spent

            print(f"地址 {address} 的详细盈利情况:")
            print(f"总花费 USD: ${total_usd_spent:.2f}")
            print(f"总收入 USD: ${total_usd_received:.2f}")
            print(f"总买入代币: {total_tokens_bought:.6f}")
            print(f"总卖出代币: {total_tokens_sold:.6f}")
            print(f"剩余代币: {remaining_tokens:.6f}")
            print(f"当前代币价格 (USD): ${current_token_price_usd:.6f}")
            print(f"当前持仓价值 (USD): ${holding_value_usd:.2f}")
            print(f"总盈利 (USD): ${total_profit_usd:.2f}")
            print(f"交易数量: {len(transactions)}")

            return float(total_profit_usd)

        except requests.exceptions.RequestException as e:
            if attempt < max_retries - 1:
                print(f"计算地址 {address} 的盈利时发生API错误: {e}")
                print(f"等待 {retry_delay} 秒后重试...")
                time.sleep(retry_delay)
            else:
                print(f"在 {max_retries} 次尝试后仍无法计算地址 {address} 的盈利")
                return 0

    return 0  # 如果所有重试都失败，返回0


def get_token_price_uniswap(token_address):
    method = "post"
    apiUrl = "https://api.1inch.dev/price/v1.1/1"
    requestOptions = {
        "headers": {
            "Authorization": "Bearer kcRqgv9yNO9dZKMnPf4VcasBBH1RPB1Z"
        },
        "body": {
            "tokens": [token_address],
            "currency": "USD"
        },
        "params": {}
    }

    headers = requestOptions.get("headers", {})
    body = requestOptions.get("body", {})
    params = requestOptions.get("params", {})

    max_retries = 3
    retry_delay = 1  # 延迟1秒

    for attempt in range(max_retries):
        try:
            response = requests.post(apiUrl, headers=headers, json=body, params=params)
            data = response.json()

            if response.status_code == 200 and token_address.lower() in data:
                token_price_usd = Decimal(data[token_address.lower()])
                print(f"从1inch API获取到的代币价格: ${token_price_usd} USD")
                return token_price_usd
            else:
                print(f"无法从1inch API获取代币 {token_address} 的价格")
                print(f"API响应: {data}")
                if attempt < max_retries - 1:
                    print(f"等待 {retry_delay} 秒后重试...")
                    time.sleep(retry_delay)
                else:
                    return Decimal('0')
        except Exception as e:
            print(f"从1inch API获取代币价格时发生错误: {e}")
            if attempt < max_retries - 1:
                print(f"等待 {retry_delay} 秒后重试...")
                time.sleep(retry_delay)
            else:
                import traceback
                traceback.print_exc()
                return Decimal('0')


def get_address_token_transactions(address, token_address, start_time, end_time):
    # 移除start_block和end_block的计算
    url = f"https://api.etherscan.io/api?module=account&action=tokentx&contractaddress={token_address}&address={address}&sort=asc&apikey={ETHERSCAN_API_KEY}"

    transactions = []
    page = 1
    while True:
        response = requests.get(f"{url}&page={page}&offset=1000")
        data = response.json()

        if data['status'] == '1':
            new_transactions = data['result']
            transactions.extend(new_transactions)

            if len(new_transactions) < 1000:
                break

            page += 1
        else:
            print(f"Error fetching transactions: {data['message']}")
            break

    return transactions

def get_transaction_eth_input(tx_hash):
    tx = web3.eth.get_transaction(tx_hash)
    receipt = web3.eth.get_transaction_receipt(tx_hash)

    total_eth_input = Decimal(Web3.from_wei(tx['value'], 'ether'))

    # 检查内部交易
    internal_txs = get_internal_transactions_for_tx(tx_hash)
    for internal_tx in internal_txs:
        if internal_tx['from'].lower() == tx['from'].lower():
            total_eth_input += Decimal(Web3.from_wei(int(internal_tx['value']), 'ether'))

    return total_eth_input

def get_weth_price_usd():
    try:
        weth_amount_wei = Web3.to_wei(1, 'ether')
        amounts = uniswap_contract.functions.getAmountsOut(
            weth_amount_wei,
            [WETH, USDC]
        ).call()
        weth_price_usd = Decimal(amounts[1]) / Decimal('1e6')  # USDC 是 6 位小数
        return float(weth_price_usd)
    except Exception as e:
        print(f"错误：从Uniswap获取WETH对USD的价格时发生异常: {e}")
        return 0


def get_internal_transactions_for_tx(tx_hash):
    url = f"https://api.etherscan.io/api?module=account&action=txlistinternal&txhash={tx_hash}&apikey={ETHERSCAN_API_KEY}"
    response = requests.get(url)
    if response.status_code == 200:
        data = response.json()
        if data['status'] == '1':
            return data['result']
    return []

def main():
    application = ApplicationBuilder().token('7321860628:AAELm29TZKQQCAmgNvDjZYO8ZLFIRKiPpA8').build()

    conv_handler = ConversationHandler(
        entry_points=[CommandHandler('analyze', analyze)],
        states={
            TOKEN_ADDRESS: [MessageHandler(filters.TEXT & ~filters.COMMAND, token_address)],
            START_TIME: [MessageHandler(filters.TEXT & ~filters.COMMAND, start_time)],
            END_TIME: [MessageHandler(filters.TEXT & ~filters.COMMAND, end_time)],
            TARGET_PROFIT: [MessageHandler(filters.TEXT & ~filters.COMMAND, target_profit)],
            MIN_BUY_WETH: [MessageHandler(filters.TEXT & ~filters.COMMAND, min_buy_weth)],
            MAX_TX_COUNT: [MessageHandler(filters.TEXT & ~filters.COMMAND, max_tx_count)],
        },
        fallbacks=[],
    )

    application.add_handler(CommandHandler('start', start))
    application.add_handler(conv_handler)

    application.run_polling()


if __name__ == '__main__':
    main()
